// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'location_service_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LocationServiceState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() locationOn,
    required TResult Function() locationOff,
    required TResult Function() locationPermissionDenied,
    required TResult Function() unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? locationOn,
    TResult? Function()? locationOff,
    TResult? Function()? locationPermissionDenied,
    TResult? Function()? unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? locationOn,
    TResult Function()? locationOff,
    TResult Function()? locationPermissionDenied,
    TResult Function()? unknownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LocationOn value) locationOn,
    required TResult Function(_LocationOff value) locationOff,
    required TResult Function(_LocationPermissionDenied value)
        locationPermissionDenied,
    required TResult Function(_UnknownError value) unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LocationOn value)? locationOn,
    TResult? Function(_LocationOff value)? locationOff,
    TResult? Function(_LocationPermissionDenied value)?
        locationPermissionDenied,
    TResult? Function(_UnknownError value)? unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LocationOn value)? locationOn,
    TResult Function(_LocationOff value)? locationOff,
    TResult Function(_LocationPermissionDenied value)? locationPermissionDenied,
    TResult Function(_UnknownError value)? unknownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationServiceStateCopyWith<$Res> {
  factory $LocationServiceStateCopyWith(LocationServiceState value,
          $Res Function(LocationServiceState) then) =
      _$LocationServiceStateCopyWithImpl<$Res, LocationServiceState>;
}

/// @nodoc
class _$LocationServiceStateCopyWithImpl<$Res,
        $Val extends LocationServiceState>
    implements $LocationServiceStateCopyWith<$Res> {
  _$LocationServiceStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialCopyWith<$Res> {
  factory _$$_InitialCopyWith(
          _$_Initial value, $Res Function(_$_Initial) then) =
      __$$_InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialCopyWithImpl<$Res>
    extends _$LocationServiceStateCopyWithImpl<$Res, _$_Initial>
    implements _$$_InitialCopyWith<$Res> {
  __$$_InitialCopyWithImpl(_$_Initial _value, $Res Function(_$_Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'LocationServiceState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() locationOn,
    required TResult Function() locationOff,
    required TResult Function() locationPermissionDenied,
    required TResult Function() unknownError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? locationOn,
    TResult? Function()? locationOff,
    TResult? Function()? locationPermissionDenied,
    TResult? Function()? unknownError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? locationOn,
    TResult Function()? locationOff,
    TResult Function()? locationPermissionDenied,
    TResult Function()? unknownError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LocationOn value) locationOn,
    required TResult Function(_LocationOff value) locationOff,
    required TResult Function(_LocationPermissionDenied value)
        locationPermissionDenied,
    required TResult Function(_UnknownError value) unknownError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LocationOn value)? locationOn,
    TResult? Function(_LocationOff value)? locationOff,
    TResult? Function(_LocationPermissionDenied value)?
        locationPermissionDenied,
    TResult? Function(_UnknownError value)? unknownError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LocationOn value)? locationOn,
    TResult Function(_LocationOff value)? locationOff,
    TResult Function(_LocationPermissionDenied value)? locationPermissionDenied,
    TResult Function(_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements LocationServiceState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$$_LocationOnCopyWith<$Res> {
  factory _$$_LocationOnCopyWith(
          _$_LocationOn value, $Res Function(_$_LocationOn) then) =
      __$$_LocationOnCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LocationOnCopyWithImpl<$Res>
    extends _$LocationServiceStateCopyWithImpl<$Res, _$_LocationOn>
    implements _$$_LocationOnCopyWith<$Res> {
  __$$_LocationOnCopyWithImpl(
      _$_LocationOn _value, $Res Function(_$_LocationOn) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_LocationOn implements _LocationOn {
  const _$_LocationOn();

  @override
  String toString() {
    return 'LocationServiceState.locationOn()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_LocationOn);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() locationOn,
    required TResult Function() locationOff,
    required TResult Function() locationPermissionDenied,
    required TResult Function() unknownError,
  }) {
    return locationOn();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? locationOn,
    TResult? Function()? locationOff,
    TResult? Function()? locationPermissionDenied,
    TResult? Function()? unknownError,
  }) {
    return locationOn?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? locationOn,
    TResult Function()? locationOff,
    TResult Function()? locationPermissionDenied,
    TResult Function()? unknownError,
    required TResult orElse(),
  }) {
    if (locationOn != null) {
      return locationOn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LocationOn value) locationOn,
    required TResult Function(_LocationOff value) locationOff,
    required TResult Function(_LocationPermissionDenied value)
        locationPermissionDenied,
    required TResult Function(_UnknownError value) unknownError,
  }) {
    return locationOn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LocationOn value)? locationOn,
    TResult? Function(_LocationOff value)? locationOff,
    TResult? Function(_LocationPermissionDenied value)?
        locationPermissionDenied,
    TResult? Function(_UnknownError value)? unknownError,
  }) {
    return locationOn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LocationOn value)? locationOn,
    TResult Function(_LocationOff value)? locationOff,
    TResult Function(_LocationPermissionDenied value)? locationPermissionDenied,
    TResult Function(_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (locationOn != null) {
      return locationOn(this);
    }
    return orElse();
  }
}

abstract class _LocationOn implements LocationServiceState {
  const factory _LocationOn() = _$_LocationOn;
}

/// @nodoc
abstract class _$$_LocationOffCopyWith<$Res> {
  factory _$$_LocationOffCopyWith(
          _$_LocationOff value, $Res Function(_$_LocationOff) then) =
      __$$_LocationOffCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LocationOffCopyWithImpl<$Res>
    extends _$LocationServiceStateCopyWithImpl<$Res, _$_LocationOff>
    implements _$$_LocationOffCopyWith<$Res> {
  __$$_LocationOffCopyWithImpl(
      _$_LocationOff _value, $Res Function(_$_LocationOff) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_LocationOff implements _LocationOff {
  const _$_LocationOff();

  @override
  String toString() {
    return 'LocationServiceState.locationOff()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_LocationOff);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() locationOn,
    required TResult Function() locationOff,
    required TResult Function() locationPermissionDenied,
    required TResult Function() unknownError,
  }) {
    return locationOff();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? locationOn,
    TResult? Function()? locationOff,
    TResult? Function()? locationPermissionDenied,
    TResult? Function()? unknownError,
  }) {
    return locationOff?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? locationOn,
    TResult Function()? locationOff,
    TResult Function()? locationPermissionDenied,
    TResult Function()? unknownError,
    required TResult orElse(),
  }) {
    if (locationOff != null) {
      return locationOff();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LocationOn value) locationOn,
    required TResult Function(_LocationOff value) locationOff,
    required TResult Function(_LocationPermissionDenied value)
        locationPermissionDenied,
    required TResult Function(_UnknownError value) unknownError,
  }) {
    return locationOff(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LocationOn value)? locationOn,
    TResult? Function(_LocationOff value)? locationOff,
    TResult? Function(_LocationPermissionDenied value)?
        locationPermissionDenied,
    TResult? Function(_UnknownError value)? unknownError,
  }) {
    return locationOff?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LocationOn value)? locationOn,
    TResult Function(_LocationOff value)? locationOff,
    TResult Function(_LocationPermissionDenied value)? locationPermissionDenied,
    TResult Function(_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (locationOff != null) {
      return locationOff(this);
    }
    return orElse();
  }
}

abstract class _LocationOff implements LocationServiceState {
  const factory _LocationOff() = _$_LocationOff;
}

/// @nodoc
abstract class _$$_LocationPermissionDeniedCopyWith<$Res> {
  factory _$$_LocationPermissionDeniedCopyWith(
          _$_LocationPermissionDenied value,
          $Res Function(_$_LocationPermissionDenied) then) =
      __$$_LocationPermissionDeniedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LocationPermissionDeniedCopyWithImpl<$Res>
    extends _$LocationServiceStateCopyWithImpl<$Res,
        _$_LocationPermissionDenied>
    implements _$$_LocationPermissionDeniedCopyWith<$Res> {
  __$$_LocationPermissionDeniedCopyWithImpl(_$_LocationPermissionDenied _value,
      $Res Function(_$_LocationPermissionDenied) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_LocationPermissionDenied implements _LocationPermissionDenied {
  const _$_LocationPermissionDenied();

  @override
  String toString() {
    return 'LocationServiceState.locationPermissionDenied()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LocationPermissionDenied);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() locationOn,
    required TResult Function() locationOff,
    required TResult Function() locationPermissionDenied,
    required TResult Function() unknownError,
  }) {
    return locationPermissionDenied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? locationOn,
    TResult? Function()? locationOff,
    TResult? Function()? locationPermissionDenied,
    TResult? Function()? unknownError,
  }) {
    return locationPermissionDenied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? locationOn,
    TResult Function()? locationOff,
    TResult Function()? locationPermissionDenied,
    TResult Function()? unknownError,
    required TResult orElse(),
  }) {
    if (locationPermissionDenied != null) {
      return locationPermissionDenied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LocationOn value) locationOn,
    required TResult Function(_LocationOff value) locationOff,
    required TResult Function(_LocationPermissionDenied value)
        locationPermissionDenied,
    required TResult Function(_UnknownError value) unknownError,
  }) {
    return locationPermissionDenied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LocationOn value)? locationOn,
    TResult? Function(_LocationOff value)? locationOff,
    TResult? Function(_LocationPermissionDenied value)?
        locationPermissionDenied,
    TResult? Function(_UnknownError value)? unknownError,
  }) {
    return locationPermissionDenied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LocationOn value)? locationOn,
    TResult Function(_LocationOff value)? locationOff,
    TResult Function(_LocationPermissionDenied value)? locationPermissionDenied,
    TResult Function(_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (locationPermissionDenied != null) {
      return locationPermissionDenied(this);
    }
    return orElse();
  }
}

abstract class _LocationPermissionDenied implements LocationServiceState {
  const factory _LocationPermissionDenied() = _$_LocationPermissionDenied;
}

/// @nodoc
abstract class _$$_UnknownErrorCopyWith<$Res> {
  factory _$$_UnknownErrorCopyWith(
          _$_UnknownError value, $Res Function(_$_UnknownError) then) =
      __$$_UnknownErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnknownErrorCopyWithImpl<$Res>
    extends _$LocationServiceStateCopyWithImpl<$Res, _$_UnknownError>
    implements _$$_UnknownErrorCopyWith<$Res> {
  __$$_UnknownErrorCopyWithImpl(
      _$_UnknownError _value, $Res Function(_$_UnknownError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnknownError implements _UnknownError {
  const _$_UnknownError();

  @override
  String toString() {
    return 'LocationServiceState.unknownError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UnknownError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() locationOn,
    required TResult Function() locationOff,
    required TResult Function() locationPermissionDenied,
    required TResult Function() unknownError,
  }) {
    return unknownError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? locationOn,
    TResult? Function()? locationOff,
    TResult? Function()? locationPermissionDenied,
    TResult? Function()? unknownError,
  }) {
    return unknownError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? locationOn,
    TResult Function()? locationOff,
    TResult Function()? locationPermissionDenied,
    TResult Function()? unknownError,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LocationOn value) locationOn,
    required TResult Function(_LocationOff value) locationOff,
    required TResult Function(_LocationPermissionDenied value)
        locationPermissionDenied,
    required TResult Function(_UnknownError value) unknownError,
  }) {
    return unknownError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LocationOn value)? locationOn,
    TResult? Function(_LocationOff value)? locationOff,
    TResult? Function(_LocationPermissionDenied value)?
        locationPermissionDenied,
    TResult? Function(_UnknownError value)? unknownError,
  }) {
    return unknownError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LocationOn value)? locationOn,
    TResult Function(_LocationOff value)? locationOff,
    TResult Function(_LocationPermissionDenied value)? locationPermissionDenied,
    TResult Function(_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError(this);
    }
    return orElse();
  }
}

abstract class _UnknownError implements LocationServiceState {
  const factory _UnknownError() = _$_UnknownError;
}
